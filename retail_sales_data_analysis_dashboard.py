# -*- coding: utf-8 -*-
"""Retail Sales Data Analysis Dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rpVEsKiE--FgUC1Os80pPRS-tajrJEfv

# Retail Sales Data Analysis Dashboard

Welcome to this Retail Sales Data Analysis project.  
In this notebook, we will load, clean, and analyze retail sales data to gain valuable business insights.  

The dataset used here is sourced from **Kaggle**,
The specific dataset is called **Retail Sales Data** and contains detailed sales records, including product IDs, store IDs, dates of sales, quantities sold, revenues, and promotional information.  

This dataset allows us to explore real-world sales transactions and customer behavior over time. By analyzing this data, we aim to:  
- Understand customer purchasing patterns  
- Segment customers based on their buying behavior using RFM (Recency, Frequency, Monetary) analysis  
- Visualize sales trends and customer segments  
- Build an interactive dashboard to make the insights accessible and actionable  

Throughout this project, we will use powerful Python libraries such as pandas for data manipulation, matplotlib and seaborn for visualizations, and scikit-learn for clustering analysis.  

Let's begin by importing the necessary libraries and loading our data for analysis!

# Step 1: Import Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from mpl_toolkits.mplot3d import Axes3D

sns.set(style="whitegrid")

"""# Step 2: Load and Preprocess Data

"""

data_path = "/content/drive/MyDrive/Colab Notebooks/data/retail_sales_data.csv"
df = pd.read_csv(data_path, low_memory=False)

print("Columns names:")
print(df.columns.tolist())
for col in df.columns:
    try:
        df[col] = pd.to_datetime(df[col])
        print(f"Converted '{col}' to datetime.")
        break
    except:
        pass

data_path = "/content/drive/MyDrive/Colab Notebooks/data/retail_sales_data.csv"
df = pd.read_csv(data_path, low_memory=False)

print("Columns names:")
print(df.columns.tolist())

# Convert first datetime column found to datetime type
for col in df.columns:
    try:
        df[col] = pd.to_datetime(df[col])
        print(f"Converted '{col}' to datetime.")
        date_col = col  # save the date column name
        break
    except:
        pass

"""# Step 3: Calculate RFM Metrics

"""

# Using 'product_id' as the "customer" identifier substitute
snapshot_date = df['date'].max() + pd.Timedelta(days=1)

rfm = df.groupby('product_id').agg({
    'date': lambda x: (snapshot_date - x.max()).days,  # Recency
    'sales': 'count',                                 # Frequency:
    'revenue': 'sum'                                  # Monetary:
})

rfm.rename(columns={
    'date': 'Recency',
    'sales': 'Frequency',
    'revenue': 'Monetary'
}, inplace=True)

print("RFM sample:")
print(rfm.head())

"""# Step 4: Assign RFM Scores"""

def safe_qcut(series, q, labels):
    try:
        return pd.qcut(series, q=q, labels=labels, duplicates='drop')
    except ValueError:
        # fallback to ranking if qcut fails
        return pd.qcut(series.rank(method='first'), q=q, labels=labels, duplicates='drop')

rfm['R_Score'] = safe_qcut(rfm['Recency'], 4, labels=[4, 3, 2, 1])
rfm['F_Score'] = safe_qcut(rfm['Frequency'], 4, labels=[1, 2, 3, 4])
rfm['M_Score'] = safe_qcut(rfm['Monetary'], 4, labels=[1, 2, 3, 4])

# Ensure no NaNs exist
rfm[['R_Score', 'F_Score', 'M_Score']] = rfm[['R_Score', 'F_Score', 'M_Score']].fillna(1).astype(int)

# Create full RFM score
rfm['RFM_Score'] = (
    rfm['R_Score'].astype(str) +
    rfm['F_Score'].astype(str) +
    rfm['M_Score'].astype(str)
)

# Display sample
print(rfm[['Recency', 'Frequency', 'Monetary', 'R_Score', 'F_Score', 'M_Score', 'RFM_Score']].head())

"""# Step 5: Visualize RFM Distributions

*   List item
*   List item


"""

plt.figure(figsize=(12,5))
sns.countplot(x='RFM_Score', data=rfm, order=rfm['RFM_Score'].value_counts().index)
plt.title('Distribution of RFM Scores')
plt.xticks(rotation=90)
plt.xlabel('RFM Score')
plt.ylabel('Number of Customers')
plt.show()

"""# Step 6: Visualization - Distributions of Recency, Frequency, Monetary"""

fig, axes = plt.subplots(1, 3, figsize=(20,5))
sns.histplot(rfm['Recency'], bins=30, kde=True, color='orange', ax=axes[0])
axes[0].set_title('Recency Distribution')
axes[0].set_xlabel('Days Since Last Purchase')

sns.histplot(rfm['Frequency'], bins=30, kde=True, color='green', ax=axes[1])
axes[1].set_title('Frequency Distribution')
axes[1].set_xlabel('Number of Purchases')

sns.histplot(rfm['Monetary'], bins=30, kde=True, color='blue', ax=axes[2])
axes[2].set_title('Monetary Distribution')
axes[2].set_xlabel('Total Spend ($)')
plt.tight_layout()
plt.show()

"""# Step 7: Elbow method to find optimal k for KMeans clustering"""

rfm_clustering = rfm[['Recency', 'Frequency', 'Monetary']]
scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm_clustering)

inertia = []
K = range(1,11)
for k in K:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(rfm_scaled)
    inertia.append(kmeans.inertia_)

plt.figure(figsize=(8,4))
plt.plot(K, inertia, 'bo-')
plt.title('Elbow Method For Optimal Number of Clusters')
plt.xlabel('Number of clusters (k)')
plt.ylabel('Inertia')
plt.show()

"""# Step 8: KMeans clustering with chosen k (e.g., k=4)"""

k = 4
kmeans = KMeans(n_clusters=k, random_state=42)
rfm['Cluster'] = kmeans.fit_predict(rfm_scaled)

print(rfm.head())

"""# Step 9: Cluster summary statistics"""

cluster_summary = rfm.groupby('Cluster').agg({
    'Recency': ['mean', 'median'],
    'Frequency': ['mean', 'median'],
    'Monetary': ['mean', 'median'],
    'RFM_Score': 'count'
}).round(1)

print(cluster_summary)

"""# Step 10: Boxplots of RFM metrics by cluster"""

fig, axes = plt.subplots(1, 3, figsize=(20,6))

sns.boxplot(x='Cluster', y='Recency', data=rfm, ax=axes[0])
axes[0].set_title('Recency by Cluster')

sns.boxplot(x='Cluster', y='Frequency', data=rfm, ax=axes[1])
axes[1].set_title('Frequency by Cluster')

sns.boxplot(x='Cluster', y='Monetary', data=rfm, ax=axes[2])
axes[2].set_title('Monetary by Cluster')

plt.show()

"""# Step 11: Pairplot of RFM variables colored by cluster

"""

sns.pairplot(rfm.reset_index(), vars=['Recency', 'Frequency', 'Monetary'], hue='Cluster', palette='Set2')
plt.suptitle('RFM Pairplot by Cluster', y=1.02)
plt.show()

"""# Step 12: Basic RFM Visualization Dashboard with Plotly"""

import plotly.express as px
import plotly.graph_objects as go
import matplotlib.pyplot as plt

# Histogram for Recency
fig_recency = px.histogram(rfm, x='Recency', nbins=20, title='Recency Distribution')
fig_recency.show()

# Histogram for Frequency
fig_frequency = px.histogram(rfm, x='Frequency', nbins=20, title='Frequency Distribution')
fig_frequency.show()

# Histogram for Monetary
fig_monetary = px.histogram(rfm, x='Monetary', nbins=20, title='Monetary Distribution')
fig_monetary.show()

# Pie chart of RFM Segment counts
rfm_counts = rfm['RFM_Score'].value_counts().reset_index()
rfm_counts.columns = ['RFM_Score', 'Count']
fig_pie = px.pie(rfm_counts, names='RFM_Score', values='Count', title='RFM Score Segments')
fig_pie.show()

# Scatter plot Recency vs Frequency
fig_scatter_rf = px.scatter(rfm, x='Recency', y='Frequency',
                            size='Monetary', color='RFM_Score',
                            title='Customer Segments (Recency vs Frequency vs Monetary)',
                            hover_data=['Monetary'])
fig_scatter_rf.show()